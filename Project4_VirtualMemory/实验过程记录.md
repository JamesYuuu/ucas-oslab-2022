# Project4 实验过程踩坑记录

## Lesson 1：什么时候取消临时映射

在`boot.c`中，为了能让其中的代码在开启虚存机制后仍然能够正常的运行，构建了一个临时映射，即将 0x50200000 到 0x51000000 所在的内核代码空间映射到 0x50200000 到 0x51000000 上，而为了保证用户程序使用这段虚拟地址的时候不与内核地址冲突，因此需要取消。

在开启单核的时候，可以简单的在开启中断前取消即可；而在开启多核后，需要等到从核进入到内核再取消，否则会导致从核无法正常执行`boot.c`中的代码。

## Lesson 2：对于栈指针的设置

### 2.1 内核栈和用户栈

从用户态进入内核态时，需要重新设置栈指针`sp`为内核栈的栈顶，这是因为我们在内核中运行函数的时候，需要调用`bios`中的函数，而`bios`中的函数需要使用物理地址，而预设好的是将内核虚地址转换为物理地址。因此我们传参的时候，也需要在内核虚地址下传参，而不是用户虚地址下传参。

因此，在进入内核前，保存上下文的时候，就需要将`sp`设置为内核栈的栈顶。

### 2.2 栈的自下而上生长

在通过`allocPage()`函数分配函数的时候，返回的是可用物理页框的起始地址，而由于栈是自下而上生长的，因此需要给起始地址+4096，才能得到栈顶。对于用户栈的分配也同样适用。

在分配用户栈的时候，我还记得这一点；但分配内核栈的时候就忘了，导致在多线程的时候出现了诸多离奇的问题，直到用gdb一步步追踪内存，才发现了是这个问题。

## Lesson 3：关于镜像中取消padding带来的不便之处

在本次的实验中，每次读入镜像，都是以4k为单位读入的。由于从sd卡中读取只能进行完整的读入，而且又不存在padding，导致在读取镜像的时候，需要进行二次移动。对每个读入的物理页框，都需要移动一部分到上次分配的物理页框中，以填补空缺，反而带来了不少不便之处。

```c
    if (page_num != 0)
        memcpy((void *)prev_kva + NORMAL_PAGE_SIZE - offset, (void *)kva, offset);
    memcpy((void *)kva, (void *)(kva + offset), NORMAL_PAGE_SIZE - offset);
```
